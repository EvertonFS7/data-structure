## ğŸ”— BinÃ¡rios

### ğŸ‡§ğŸ‡· O que Ã©?

Os **nÃºmeros binÃ¡rios** sÃ£o compostos apenas por 0 e 1. Cada dÃ­gito binÃ¡rio Ã© um **bit** e sua posiÃ§Ã£o representa uma potÃªncia de 2.  
Esses nÃºmeros sÃ£o fundamentais para o funcionamento dos computadores, pois eles processam e armazenam dados usando apenas essas duas opÃ§Ãµes (0 e 1).

Por exemplo, o nÃºmero binÃ¡rio **1011** corresponde a **11** no sistema decimal, porque:

- **1** Ã— 2Â³ = 8
- **0** Ã— 2Â² = 0
- **1** Ã— 2Â¹ = 2
- **1** Ã— 2â° = 1

Ou seja, **1011** = 8 + 0 + 2 + 1 = **11**.

---

### ğŸ‡§ğŸ‡· Como Ã© feito o cÃ¡lculo de binÃ¡rios?

O cÃ¡lculo binÃ¡rio segue regras simples. Na **soma**, usamos as regras:

- 0 + 0 = 0
- 1 + 0 = 1
- 1 + 1 = 10 (vai para a prÃ³xima casa)

Para **multiplicaÃ§Ã£o** e **divisÃ£o**, usamos as potÃªncias de 2 para deslocar os bits.

---

### ğŸ‡§ğŸ‡· Left and Right Shift

- **Left Shift (<<)**: Desloca os bits Ã  esquerda, multiplicando o nÃºmero por 2 a cada deslocamento.  
Exemplo: `0001 << 1 = 0010` (multiplicado por 2)

- **Right Shift (>>)**: Desloca os bits Ã  direita, dividindo o nÃºmero por 2 a cada deslocamento.  
Exemplo: `0100 >> 1 = 0010` (dividido por 2)

---

### ğŸ‡§ğŸ‡· OperaÃ§Ãµes LÃ³gicas

- **AND (E)**: Retorna 1 se ambos os bits forem 1, caso contrÃ¡rio, retorna 0.  
Exemplo: `1 AND 1 = 1`, `1 AND 0 = 0`

- **OR (OU)**: Retorna 1 se pelo menos um dos bits for 1.  
Exemplo: `1 OR 0 = 1`, `0 OR 0 = 0`

- **NOT (NÃƒO)**: Inverte os bits.  
Exemplo: `NOT 1 = 0`, `NOT 0 = 1`

- **XOR (OU Exclusivo)**: Retorna 1 se os bits forem diferentes, caso contrÃ¡rio, retorna 0.  
Exemplo: `1 XOR 0 = 1`, `1 XOR 1 = 0`

---

### ğŸ‡ºğŸ‡¸ What is it?

**Binary numbers** are made up of only 0 and 1. Each binary digit is a **bit**, and its position represents a power of 2.  
These numbers are essential for the operation of computers, as they process and store data using just these two options (0 and 1).

For example, the binary number **1011** corresponds to **11** in the decimal system because:

- **1** Ã— 2Â³ = 8
- **0** Ã— 2Â² = 0
- **1** Ã— 2Â¹ = 2
- **1** Ã— 2â° = 1

So, **1011** = 8 + 0 + 2 + 1 = **11**.

---

### ğŸ‡ºğŸ‡¸ How is binary calculation done?

Binary calculation follows simple rules. In **addition**, we use the rules:

- 0 + 0 = 0
- 1 + 0 = 1
- 1 + 1 = 10 (carry to the next place)

For **multiplication** and **division**, we use powers of 2 to shift the bits.

---

### ğŸ‡ºğŸ‡¸ Left and Right Shift

- **Left Shift (<<)**: Moves the bits to the left, multiplying the number by 2 for each shift.  
Example: `0001 << 1 = 0010` (multiplied by 2)

- **Right Shift (>>)**: Moves the bits to the right, dividing the number by 2 for each shift.  
Example: `0100 >> 1 = 0010` (divided by 2)

---

### ğŸ‡ºğŸ‡¸ Logical Operations

- **AND**: Returns 1 if both bits are 1, otherwise returns 0.  
Example: `1 AND 1 = 1`, `1 AND 0 = 0`

- **OR**: Returns 1 if at least one bit is 1.  
Example: `1 OR 0 = 1`, `0 OR 0 = 0`

- **NOT**: Inverts the bits.  
Example: `NOT 1 = 0`, `NOT 0 = 1`

- **XOR**: Returns 1 if the bits are different, otherwise returns 0.  
Example: `1 XOR 0 = 1`, `1 XOR 1 = 0`
